name: Manual Generate Linux Binary/AppImage
on:
  workflow_dispatch:
    inputs:

      buildVariant:
        type: choice
        description: 'Build Variant'
        required: true
        default: 'release'
        options: 
        - release
        - debug

      cpuArch:
        type: choice
        description: 'CPU Architecture'
        required: true
        default: 'x86_64'
        options: 
        - x86_64  # native performance
        - x86     # native performance
        - aarch64
        - armhf   # Since this runs on QEMU: both "armhf" and
        - armv7   #     "armv7" shows "armv7l" on "uname -m" but "cat /proc/cpuinfo" shows (v8l) with neon feature
        - riscv64
        - ppc64le
        - s390x

      createAppImage:
        type: boolean
        description: 'Create AppImage bundle'
        required: true
        default: true

      runTest:
        type: boolean
        description: 'Run Tests'
        required: true
        default: false

jobs:

  build:
    name: Generate ${{ github.event.inputs.buildVariant }} ${{ github.event.inputs.cpuArch }} build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Check Valid Version Tags
        id: valid-tags
        shell: bash
        run: |
          echo "count=$(git tag -l 'v[0-9]*' | wc -l | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Fetch upstream tags # required for git describe to return a valid version and to preevnt androidGitVersion from crashing on a new fork
        if: ${{ steps.valid-tags.outputs.count == '0' }}
        run: |
          # TODO: should try to fetch tags from whereever this repo was forked from before fetching from official repo
          git remote add upstream https://github.com/hrydgard/ppsspp.git # fetching from official repo as a fallback
          git fetch --deepen=15000 --no-recurse-submodules --tags upstream || exit 0

      - name: Supposedly a Workaround before running AppImage in a container without patching the magic bytes
        run: |
          update-binfmts --display
          # run this on the host, might affect the host permanently on the runner (even on the next runs) and can't be enabled again without reinstalling!
          #sudo update-binfmts --disable appimage-type2

          # to reenable, use:
          #sudo add-apt-repository ppa:appimagelauncher-team/stable
          #sudo apt update
          #sudo apt install appimagelauncher -y
          # automatic from appimagelauncher: update-binfmts --package appimage --install appimage-type1 /usr/bin/AppImageLauncher --magic 'AI\x01' --offset 8
          # automatic from appimagelauncher: update-binfmts --package appimage --install appimage-type2 /usr/bin/AppImageLauncher --magic 'AI\x02' --offset 8
          #sudo update-binfmts --enable appimage-type2
      
      - name: Set up Alpine Linux for ${{ github.event.inputs.cpuArch }} (Target arch)
        id: alpine-target
        uses: jirutka/setup-alpine@v1
        with:
          arch: ${{ github.event.inputs.cpuArch }}
          branch: edge # "${{ github.event.inputs.cpuArch == 'armhf' && 'v3.18' || 'v3.20' }}" # riscv64 only supported on edge (or v3.20+ ?), but LFS64 interfaces (*64 syscall shims like fopen64) have been removed since musl 1.2.4 (Alpine v3.19 or v3.18 ?)
          shell-name: alpine-target.sh

      - name: Setup ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: linux-${{ github.event.inputs.buildVariant }}-${{ github.event.inputs.cpuArch }}
          create-symlink: true

      - name: Run script inside Alpine chroot (Build Target arch)
        env:
          CC: gcc
          CXX: g++
          CPPFLAGS: -fPIC -fno-pie -fno-plt -no-pie -static -D_XOPEN_SOURCE=700 #-D_GNU_SOURCE # -fno-split-stack
          LDFLAGS: -no-pie -static
          USE_CCACHE: 1
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          uname -a
          cat /proc/cpuinfo
          apk list -i
          apk update
          apk add --upgrade apk-tools
          apk upgrade --available
          apk add build-base wget git bash zip cmake python3 glu-dev fuse fuse3 fuse3-libs gcompat # sdl2-dev sdl2_ttf-dev fontconfig-dev glew-dev # need to install sdl2 from source when using Alpine v3.18 or older?
          #apk add clang lld compiler-rt && clang --version && clang++ --version
          pwd
          gcc -v 2>&1 | grep -o -e '[^ ]*pie' # Checking default pie flags
          gcc --version
          g++ --version
          ld -v
          
          # Fix dubious ownership issue when running git describe inside a container
          git config --global --add safe.directory "$PWD"

          # Export ccache env var(s)
          export PATH="/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          export CCACHE_SLOPPINESS=clang_index_store,ivfsoverlay,include_file_ctime,include_file_mtime,modules,system_headers,time_macros
        
          # Build SDL2 from source (Apline v3.17 (musl 1.2.3-r5) have SDL2 version 2.26.5-r0 but have directfb.h issue on some arch)
          export SDL_VERSION=2.0.22
          wget https://github.com/libsdl-org/SDL/archive/refs/tags/release-${SDL_VERSION}.tar.gz && \
          tar -xf release-${SDL_VERSION}.tar.gz && cd SDL-release-${SDL_VERSION} && mkdir build && cd build && \
          cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DSDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS=1 .. && \
          make -j$(getconf _NPROCESSORS_ONLN) clean && \
          make -j$(getconf _NPROCESSORS_ONLN) && \
          make -j$(getconf _NPROCESSORS_ONLN) install
          cd .. && cd ..
          # End of Build SDL2 from source

          #rm -f ./ffmpeg/linux/armv7/lib/libavutil.a
          #find . -name libavutil.a
          #rm -f ./ffmpeg/linux/x86/lib/libavcodec.a
          #find . -name libavcodec.a
          # Build a minimal FFMPEG (without recompiling some arch may get 'fopen64' or 'fcntl64' issue during PPSSPP linking)
          cd ffmpeg
          rm -f config.h
          set -e

          # armhf can be detected as armv7l too! Since PPSSPP will search "^armv7" libraries at /armv7/ subdirecory, so here we go:
          #ARCH="${{ github.event.inputs.cpuArch == 'armhf' && 'armv7' || github.event.inputs.cpuArch }}"
          # PPSSPP will fallback to x86_64 search path with Unknown CMAKE_SYSTEM_PROCESSOR
          ARCH="${{ github.event.inputs.cpuArch }}"
          ARCHDIR=${ARCH}
          if [ "${{ github.event.inputs.cpuArch }}" == "armhf" ]; then
            ARCH="armv7"
            ARCHDIR="armv7"
          elif [ "${{ github.event.inputs.cpuArch }}" == "ppc64le" ]; then
            ARCHDIR="x86_64"
          fi
          #   --enable-cross-compile \
          #   --cc=mipsel-linux-gcc \
          #   --cxx=mipsel-linux-g++ \
          #   --extra-libs="-lgcc" \
          
          GENERAL="
             --target-os=linux \
             --disable-shared \
             --enable-static"
          
          MODULES="\
             --disable-avdevice \
             --disable-filters \
             --disable-programs \
             --disable-network \
             --disable-avfilter \
             --disable-postproc \
             --disable-encoders \
             --disable-doc \
             --disable-ffplay \
             --disable-ffprobe \
             --disable-ffserver \
             --disable-ffmpeg"
          
          VIDEO_DECODERS="\
             --enable-decoder=h264 \
             --enable-decoder=h263 \
             --enable-decoder=h263p \
             --enable-decoder=mpeg2video"
          
          AUDIO_DECODERS="\
              --enable-decoder=aac \
              --enable-decoder=atrac3 \
              --enable-decoder=atrac3p \
              --enable-decoder=mp3 \
              --enable-decoder=pcm_s16le \
              --enable-decoder=pcm_s8"
            
          DEMUXERS="\
              --enable-demuxer=h264 \
              --enable-demuxer=h263 \
              --enable-demuxer=mpegps \
              --enable-demuxer=mpegvideo \
              --enable-demuxer=avi \
              --enable-demuxer=mp3 \
              --enable-demuxer=aac \
              --enable-demuxer=oma \
              --enable-demuxer=pcm_s16le \
              --enable-demuxer=pcm_s8 \
              --enable-demuxer=wav"
          
          VIDEO_ENCODERS="\
              --enable-encoder=huffyuv
              --enable-encoder=ffv1
              --enable-encoder=mjpeg"
          
          AUDIO_ENCODERS="\
              --enable-encoder=pcm_s16le"
          
          MUXERS="\
              --enable-muxer=avi"
          
          PARSERS="\
              --enable-parser=h264 \
              --enable-parser=mpeg4video \
              --enable-parser=mpegvideo \
              --enable-parser=aac \
              --enable-parser=mpegaudio"

          echo "VIDEO_ENCODERS="${VIDEO_ENCODERS}

          # cflags: -static-pie
          # ldflags when using --enable-pic: -Wl,-Bsymbolic # -pie --no-dynamic-linker
          # extra-ldexeflags If your target platform requires position independent binaries: -pie # -no-pie
          ./configure \
              --prefix=./linux/${ARCHDIR} \
              ${GENERAL} \
              --extra-cflags="-D__STDC_CONSTANT_MACROS -O3" \
              --extra-cxxflags="-D__STDC_CONSTANT_MACROS -O3" \
              --extra-ldflags="-Wl,-Bsymbolic" \
              --enable-pic \
              --enable-zlib \
              --disable-yasm \
              --disable-everything \
              ${MODULES} \
              ${VIDEO_DECODERS} \
              ${AUDIO_DECODERS} \
              ${VIDEO_ENCODERS} \
              ${AUDIO_ENCODERS} \
              ${DEMUXERS} \
              ${MUXERS} \
              ${PARSERS} \
              --arch=${ARCH} \
             
          make clean
          make install
          cd ..
          # End of Build a minimal FFMPEG
          #find . -name libavutil.a
          #find . -name libavcodec.a

          # TODO: riscv64 might have '__riscv_flush_icache' issue, may be need to use a different toolchain?
          ./b.sh --${{ github.event.inputs.buildVariant }}
        shell: alpine-target.sh --root {0}

      - name: Run script on the Host system
        run: |
          uname -a
          cat /proc/cpuinfo
          apt list --installed
          pwd
          gcc -v 2>&1 | grep -o -e '[^ ]*pie' # Checking default pie flags
        shell: bash
      
      - name: Package Standard Binary build
        if: ${{ github.event.inputs.createAppImage == 'false' }}
        run: |
          find . -name "PPSSPPSDL" -exec file {} \;
          mkdir ppsspp
          if [ -e build*/PPSSPPSDL ]; then
            cp -a build*/PPSSPPSDL ppsspp/
            chmod +x ppsspp/PPSSPPSDL
            cp -r assets ppsspp/assets
          fi

      - name: Package AppImage build (on target arch)
        if: ${{ github.event.inputs.createAppImage != 'false' }}
        env:
          APPIMAGE_EXTRACT_AND_RUN: 1
          NO_STRIP: 'true'
        run: |
          pwd
          echo $HOME
          find . -name "PPSSPPSDL" -exec file {} 
          cd build
          if [ "${{ github.event.inputs.cpuArch }}" == "x86" ]; then
            APPIMAGETOOL=$(wget -q https://api.github.com/repos/probonopd/go-appimage/releases -O - | sed 's/"/ /g; s/ /\n/g' | grep -o 'https.*continuous.*tool.*i686.*mage$')
          	wget -q "$APPIMAGETOOL" -O ./appimagetool-i686.AppImage
            # Patch the ELF header (magic bytes) of the AppImage to ensure it's always executable, even without AppImageLauncher (ie. Docker/chroot)
            sed "0,/AI\x02/{s|AI\x02|\x00\x00\x00|}" -i appimagetool-i686.AppImage
            chmod +x appimagetool-i686.AppImage

            #wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-i386.AppImage
            #sed "0,/AI\x02/{s|AI\x02|\x00\x00\x00|}" -i linuxdeploy-i386.AppImage
            #chmod +x linuxdeploy-i386.AppImage
    
            chmod +x ./../scripts/makeappimage_32-bit.sh
            ./../scripts/makeappimage_32-bit.sh # linuxdeploy-x86_64.AppImage might be missing some library or not support Alpine Linux?
          elif [ "${{ github.event.inputs.cpuArch }}" == "x86_64" ]; then
            APPIMAGETOOL=$(wget -q https://api.github.com/repos/probonopd/go-appimage/releases -O - | sed 's/"/ /g; s/ /\n/g' | grep -o 'https.*continuous.*tool.*86_64.*mage$')
          	wget -q "$APPIMAGETOOL" -O ./appimagetool-x86_64.AppImage
            # Patch the ELF header (magic bytes) of the AppImage to ensure it's always executable, even without AppImageLauncher (ie. Docker/chroot)
            sed "0,/AI\x02/{s|AI\x02|\x00\x00\x00|}" -i appimagetool-x86_64.AppImage
            chmod +x appimagetool-x86_64.AppImage

            #wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
            #sed "0,/AI\x02/{s|AI\x02|\x00\x00\x00|}" -i linuxdeploy-x86_64.AppImage
            #chmod +x linuxdeploy-x86_64.AppImage
            
            chmod +x ./../scripts/makeappimage_64-bit.sh
            ./../scripts/makeappimage_64-bit.sh # linuxdeploy-x86_64.AppImage might be missing some library or not support Alpine Linux?
          fi
          cd -
          mkdir ppsspp
          find . -name "AppRun" -exec file {} \;
          find ./build -type f -name "PPSSPP*.AppImage" -exec file {} \; -exec chmod +x {} \; -exec cp -a {} ppsspp/ \;
        shell: alpine-target.sh --root {0}

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ github.event.inputs.buildVariant }}-${{ github.event.inputs.cpuArch }} build
          path: ppsspp/

      - name: Run script inside Alpine chroot (Build Tests)
        if: ${{ github.event.inputs.runTest != 'false' }}
        #working-directory: ${{ env.GITHUB_WORKSPACE }}
        env:
          CC: gcc
          CXX: g++
          CPPFLAGS: -fPIC -fno-pie -fno-plt -no-pie -static -D_XOPEN_SOURCE=700 #-D_GNU_SOURCE # -fno-split-stack
          LDFLAGS: -no-pie -static
          USE_CCACHE: 1
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          # Build tests
          ./b.sh --headless --unittest
          file ./ffmpeg/linux/x86/lib/libavcodec.a
          find . -name PPSSPPHeadless -exec file {} \;
          find . -name PPSSPPUnitTest -exec file {} \;
        shell: alpine-target.sh --root {0}

      - name: Package Test build
        run: |
          find . -name "PPSSPPHeadless" -exec file {} \;
          mkdir test
          if [ -e build*/PPSSPPHeadless ]; then
            cp build*/PPSSPPHeadless test/
            cp -r assets test/assets
          fi
          find . -name "PPSSPPUnitTest" -exec file {} \;
          if [ -e build*/PPSSPPUnitTest ]; then
            cp build*/PPSSPPUnitTest test/
          fi

      - name: Upload Test artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ github.event.inputs.buildVariant }}-${{ github.event.inputs.cpuArch }} headless
          path: test/

  test:
    name: Testing Headless & Unit tests
    if: ${{ github.event.inputs.runTest != 'false' }}
    #continue-on-error: true
    strategy:
      fail-fast: false
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 30
    env:
      CROSS_SYSROOT: /mnt/alpine-${{ github.event.inputs.cpuArch }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: false
  
      - name: Fetch tests
        working-directory: ${{ env.GITHUB_WORKSPACE }}
        # Doing this to avoid ffmpeg and other large submodules.
        run: git submodule update --init pspautotests assets/lang

      #- name: Set up Alpine Linux for ${{ github.event.inputs.cpuArch }} (Build arch)
      #  id: alpine-build
      #  uses: jirutka/setup-alpine@v1
      #  with:
      #    arch: ${{ github.event.inputs.cpuArch }}
      #    branch: edge
      #    packages: >
      #      build-base
      #      wget
      #      git
      #      bash
      #      cmake
      #      python3
      #      glu-dev
      #    shell-name: alpine-build.sh

      - name: Set up Alpine Linux for ${{ github.event.inputs.cpuArch }} (Test arch)
        id: alpine-test
        uses: jirutka/setup-alpine@v1
        with:
          arch: ${{ github.event.inputs.cpuArch }}
          branch: edge
          packages: >
            sdl2
            libstdc++
            glu-dev
            #gcompat
          shell-name: alpine-test.sh

      - name: Download Test build
        uses: actions/download-artifact@v4
        with:
          name: linux-${{ github.event.inputs.buildVariant }}-${{ github.event.inputs.cpuArch }} headless
          path: test/
  
      #- name: Run script inside Alpine chroot (Build Tests)
      #  working-directory: ${{ env.GITHUB_WORKSPACE }}
      #  run: |
      #    uname -a
      #    # Fix dubious ownership issue when running git describe inside a container
      #    git config --global --add safe.directory "$PWD"
      #    
      #    # Build tests
      #    ./b.sh --headless --unittest
      #  shell: alpine-build.sh --root {0}
        
      - name: Fix test permissions
        working-directory: ${{ env.GITHUB_WORKSPACE }}
        run: |
          #cp `find . -name PPSSPPHeadless` .
          find . -name PPSSPPHeadless
          find . -name PPSSPPHeadless -exec cp "{}" . \;
          chmod +x PPSSPPHeadless
          #cp `find . -name PPSSPPUnitTest` .
          find . -name PPSSPPUnitTest
          find . -name PPSSPPUnitTest -exec cp "{}" . \;
          chmod +x PPSSPPUnitTest
        shell: alpine-test.sh --root {0}
  
      - name: Execute Unit tests
        continue-on-error: true
        working-directory: ${{ env.GITHUB_WORKSPACE }}
        env:
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          uname -a
          find . -name "PPSSPPUnitTest" -exec file {} \;
          if [ -e ./PPSSPPUnitTest ]; then
            ./PPSSPPUnitTest ALL
          fi
        shell: alpine-test.sh --root {0}
  
      - name: Execute Headless tests
        working-directory: ${{ env.GITHUB_WORKSPACE }}
        env:
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          uname -a
          find . -name PPSSPPHeadless -exec file {} \;
          if [ -e PPSSPPHeadless ]; then
            python test.py -g --graphics=software
          fi
        shell: alpine-test.sh --root {0}
        
